name: Secure Deploy to Production

on:
  push:
    branches: [ "master" ]
  workflow_dispatch:
    inputs:
      force_ssl_renew:
        description: 'Force SSL certificate renewal'
        required: false
        default: false
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Security Audit - npm packages
        run: |
          cd apps/web
          npm ci --legacy-peer-deps --ignore-scripts
          echo "=== Running npm audit ==="
          npm audit --audit-level=high || echo "::warning::npm audit found vulnerabilities - review before production"
        continue-on-error: true

      - name: Compress Files
        run: |
          tar --exclude='.git' -czf /tmp/deploy_package.tar.gz .
          mv /tmp/deploy_package.tar.gz ./deploy_package.tar.gz

      - name: Copy Files to Server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "deploy_package.tar.gz"
          target: ${{ secrets.DEPLOY_PATH }}
          rm: true # Clean target folder before copy to remove any leftovers
          timeout: 300s # Set timeout to 5 minutes
          command_timeout: 30m # Set command timeout to 30 minutes

      - name: Execute Full Deployment
        uses: appleboy/ssh-action@v1.0.3
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_NAME: ${{ secrets.DB_NAME }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          SSL_EMAIL: ${{ secrets.SSL_EMAIL }}
          DOMAIN: ${{ secrets.DOMAIN }}
          ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }}
          EXTENSION_ORIGIN: ${{ secrets.EXTENSION_ORIGIN }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          timeout: 300s
          command_timeout: 30m
          envs: DB_PASSWORD,DB_USER,DB_NAME,JWT_SECRET_KEY,SSL_EMAIL,DOMAIN,ALLOWED_ORIGINS,EXTENSION_ORIGIN,DEPLOY_PATH
          script: |
            set -e
            cd ${DEPLOY_PATH}
            
            # Enable Docker Content Trust for image verification
            export DOCKER_CONTENT_TRUST=1
            
            # Unpack the deployment package
            tar xzf deploy_package.tar.gz
            rm deploy_package.tar.gz

            # Replace placeholders in nginx configs with actual values from secrets
            echo "=== Substituting config placeholders with secrets ==="
            sed -i "s/__HOST_IP__/${{ secrets.HOST }}/g" nginx/nginx.http.conf
            sed -i "s/__HOST_IP__/${{ secrets.HOST }}/g" nginx/nginx.ssl.conf
            sed -i "s/__DOMAIN__/${DOMAIN}/g" nginx/nginx.http.conf
            sed -i "s/__DOMAIN__/${DOMAIN}/g" nginx/nginx.ssl.conf

            # Create .env file from environment variables
            echo "DB_PASSWORD=${DB_PASSWORD}" > .env
            echo "DB_USER=${DB_USER}" >> .env
            echo "DB_NAME=${DB_NAME}" >> .env
            echo "JWT_SECRET_KEY=${JWT_SECRET_KEY}" >> .env
            echo "SSL_EMAIL=${SSL_EMAIL}" >> .env
            echo "DOMAIN=${DOMAIN}" >> .env
            
            # Auto-detect SSL: Use HTTPS domain if cert exists, IP address otherwise
            SSL_CERT_PATH="./nginx/ssl/live/${DOMAIN}/fullchain.pem"
            if [ -f "$SSL_CERT_PATH" ]; then
              echo "API_URL=https://${DOMAIN}" >> .env
              echo "=== SSL certificate found, using HTTPS ==="
            else
              # Use IP address when SSL not available to avoid cross-origin issues
              echo "API_URL=http://${{ secrets.HOST }}" >> .env
              echo "=== No SSL certificate, using HTTP with IP ==="
            fi
            
            echo "ALLOWED_ORIGINS=${ALLOWED_ORIGINS}" >> .env
            echo "EXTENSION_ORIGIN=${EXTENSION_ORIGIN}" >> .env
            
            echo "=== Checking existing containers ==="
            docker ps -a || true
            
            # Remove any manually created containers that might conflict
            echo "=== Cleaning up conflicting containers ==="
            docker rm -f clinics-nginx 2>/dev/null || true
            docker rm -f clinics-api 2>/dev/null || true
            docker rm -f clinics-web 2>/dev/null || true
            docker rm -f clinics-db 2>/dev/null || true
            
            # ===========================================
            # SSL CERTIFICATE MANAGEMENT (Rate Limit Safe)
            # ===========================================
            SSL_CERT_PATH="./nginx/ssl/live/${DOMAIN}/fullchain.pem"
            CERTBOT_LOCK_FILE="/tmp/certbot_last_run"
            FORCE_SSL_RENEW="${{ inputs.force_ssl_renew }}"
            NEED_CERTBOT=false
            
            # Check if certificate exists
            if [ ! -f "$SSL_CERT_PATH" ]; then
              echo "=== No SSL certificate found ==="
              NEED_CERTBOT=true
            else
              # Check if certificate expires within 30 days
              EXPIRY_DATE=$(openssl x509 -enddate -noout -in "$SSL_CERT_PATH" 2>/dev/null | cut -d= -f2)
              if [ -n "$EXPIRY_DATE" ]; then
                EXPIRY_EPOCH=$(date -d "$EXPIRY_DATE" +%s 2>/dev/null || echo 0)
                NOW_EPOCH=$(date +%s)
                DAYS_LEFT=$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))
                echo "=== SSL certificate expires in $DAYS_LEFT days ==="
                if [ "$DAYS_LEFT" -lt 30 ]; then
                  echo "=== Certificate expiring soon, renewal needed ==="
                  NEED_CERTBOT=true
                fi
              fi
            fi
            
            # Force renewal if manually triggered
            if [ "$FORCE_SSL_RENEW" = "true" ]; then
              echo "=== Force SSL renewal requested ==="
              NEED_CERTBOT=true
            fi
            
            # Rate limit protection: Check if certbot ran recently (within 6 hours)
            if [ "$NEED_CERTBOT" = "true" ] && [ -f "$CERTBOT_LOCK_FILE" ]; then
              LAST_RUN=$(cat "$CERTBOT_LOCK_FILE" 2>/dev/null || echo 0)
              NOW=$(date +%s)
              HOURS_SINCE=$(( (NOW - LAST_RUN) / 3600 ))
              if [ "$HOURS_SINCE" -lt 6 ] && [ "$FORCE_SSL_RENEW" != "true" ]; then
                echo "=== Certbot ran $HOURS_SINCE hours ago, skipping to avoid rate limit ==="
                NEED_CERTBOT=false
              fi
            fi
            
            # Run certbot if needed
            if [ "$NEED_CERTBOT" = "true" ]; then
              echo "=== Attempting to obtain SSL certificate ==="
              
              # Use HTTP-only nginx config first for ACME challenge
              if [ -f "nginx/nginx.http.conf" ]; then
                cp nginx/nginx.http.conf nginx/nginx.conf
              fi
              
              # Start/restart services with HTTP config
              docker compose -f docker-compose.prod.yml up -d --build --remove-orphans
              
              # Wait for services to be ready
              echo "Waiting for services to start..."
              sleep 15
              
              # Record attempt time (before running, to prevent rapid retries on failure)
              date +%s > "$CERTBOT_LOCK_FILE"
              
              # Obtain SSL certificate
              docker compose -f docker-compose.prod.yml --profile ssl run --rm certbot && {
                echo "=== SSL certificate obtained successfully ==="
                
                # Switch to SSL nginx config
                if [ -f "nginx/nginx.ssl.conf" ]; then
                  cp nginx/nginx.ssl.conf nginx/nginx.conf
                  docker compose -f docker-compose.prod.yml restart nginx
                  echo "=== Switched to HTTPS configuration ==="
                fi
              } || {
                echo "=== Certbot failed (possibly rate limited), continuing with HTTP ==="
                echo "=== Next retry allowed in 6 hours or with force_ssl_renew ==="
              }
            elif [ -f "$SSL_CERT_PATH" ]; then
              echo "=== SSL certificate valid, using HTTPS config ==="
              
              # Use SSL nginx config
              if [ -f "nginx/nginx.ssl.conf" ]; then
                cp nginx/nginx.ssl.conf nginx/nginx.conf
              fi
              
              # Build and start all services
              docker compose -f docker-compose.prod.yml up -d --build --remove-orphans
            else
              echo "=== No SSL certificate, starting with HTTP config ==="
              
              # Use HTTP nginx config
              if [ -f "nginx/nginx.http.conf" ]; then
                cp nginx/nginx.http.conf nginx/nginx.conf
              fi
              
              # Build and start all services
              docker compose -f docker-compose.prod.yml up -d --build --remove-orphans
            fi
            
            # Wait for health checks
            echo "=== Waiting for services to be healthy ==="
            sleep 10
            
            # Verify deployment
            echo "=== Container Status ==="
            docker compose -f docker-compose.prod.yml ps
            
            # Reload nginx to ensure all config changes are applied
            echo "=== Reloading Nginx ==="
            docker exec clinics-nginx nginx -t && docker exec clinics-nginx nginx -s reload || echo "Nginx reload skipped"
            
            # Test health endpoint
            echo "=== Health Check ==="
            curl -sf http://127.0.0.1/health 2>/dev/null || curl -sf https://127.0.0.1/health --insecure 2>/dev/null || echo "Health check pending..."
            
            # Show container health status
            echo "=== Container Health ==="
            docker inspect --format='{{.Name}}: {{.State.Status}} {{if .State.Health}}({{.State.Health.Status}}){{end}}' $(docker ps -q) 2>/dev/null || true
            
            # Prune unused images
            docker image prune -f
            
            # ===========================================
            # SECURITY HARDENING (runs on each deploy)
            # ===========================================
            echo "=== Applying Security Hardening ==="
            
            # 1. Secure file permissions for sensitive files
            chmod 600 .env 2>/dev/null || true
            chmod 600 nginx/ssl/live/${DOMAIN}/privkey.pem 2>/dev/null || true
            
            # 2. Remove unnecessary packages and clear temp files
            rm -rf /tmp/* 2>/dev/null || true
            
            # 3. Verify UFW is active
            if command -v ufw &> /dev/null; then
              echo "UFW Status:"
              sudo ufw status | head -5
            fi
            
            # 4. Verify Fail2Ban is active
            if command -v fail2ban-client &> /dev/null; then
              echo "Fail2Ban Status:"
              sudo fail2ban-client status | head -3
            fi
            
            # 5. Show security summary
            echo "=== Security Summary ==="
            echo "- .env file permissions: $(stat -c '%a' .env 2>/dev/null || echo 'N/A')"
            echo "- SSL cert expires: $(openssl x509 -enddate -noout -in nginx/ssl/live/${DOMAIN}/fullchain.pem 2>/dev/null | cut -d= -f2 || echo 'N/A')"
            echo "- Docker containers running: $(docker ps -q | wc -l)"
            
            echo "=== Deployment complete ==="

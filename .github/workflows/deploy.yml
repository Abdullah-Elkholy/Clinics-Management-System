name: Secure Deploy to Production

on:
  push:
    branches: [ "master" ]
  workflow_dispatch:
    inputs:
      force_ssl_renew:
        description: 'Force SSL certificate renewal'
        required: false
        default: false
        type: boolean

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Preflight - verify SSH reachable from runner
        shell: bash
        env:
          HOST: ${{ secrets.HOST }}
        run: |
          set -euo pipefail
          echo "=== DNS resolution (may be masked) ==="
          getent hosts "$HOST" || true
          echo "=== Checking TCP 22 reachability ==="
          # Fail fast with a clear error if GitHub-hosted runners cannot reach the server.
          if timeout 7 bash -lc "cat < /dev/null > /dev/tcp/${HOST}/22"; then
            echo "SSH port 22 reachable"
          else
            echo "::error::Cannot reach ${HOST}:22 from GitHub runner (timeout). Check provider firewall/ACL, Fail2Ban bans, or wrong HOST/port."
            exit 1
          fi

      - name: Bootstrap Server (if fresh)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          debug: true
          timeout: 300s
          command_timeout: 15m
          script: |
            # ===========================================
            # ZERO-TOUCH BOOTSTRAP FOR FRESH SERVERS
            # Only runs full setup if Docker not installed
            # ===========================================
            if ! command -v docker &> /dev/null; then
              echo "=== Fresh server detected, running bootstrap ==="
              
              # Update system
              apt update && apt upgrade -y
              
              # Install Docker v2
              curl -fsSL https://get.docker.com | sh
              systemctl enable docker
              systemctl start docker
              
              # Install Fail2Ban
              apt install -y fail2ban
              systemctl enable fail2ban
              systemctl start fail2ban
              
              # Configure firewall
              ufw default deny incoming
              ufw default allow outgoing
              ufw allow 22/tcp
              ufw allow 80/tcp
              ufw allow 443/tcp
              echo "y" | ufw enable
              
              # Harden SSH (disable password auth)
              sed -i 's/#PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
              sed -i 's/PasswordAuthentication yes/PasswordAuthentication no/' /etc/ssh/sshd_config
              sed -i 's/PermitRootLogin yes/PermitRootLogin prohibit-password/' /etc/ssh/sshd_config
              systemctl restart ssh
              
              echo "=== Bootstrap complete! ==="
            else
              echo "=== Docker already installed, skipping bootstrap ==="
              docker --version
            fi
            
            # Always ensure deploy directory exists
            mkdir -p ${{ secrets.DEPLOY_PATH }}

      - name: Security Audit - npm packages
        run: |
          cd apps/web
          npm ci --legacy-peer-deps --ignore-scripts
          echo "=== Running npm audit ==="
          npm audit --audit-level=high || echo "::warning::npm audit found vulnerabilities - review before production"
        continue-on-error: true

      - name: Compress Files
        run: |
          tar --exclude='.git' -czf /tmp/deploy_package.tar.gz .
          mv /tmp/deploy_package.tar.gz ./deploy_package.tar.gz

      - name: Copy Files to Server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: "deploy_package.tar.gz"
          target: ${{ secrets.DEPLOY_PATH }}
          rm: false # IMPORTANT: do NOT wipe deploy folder (preserves nginx/ssl Let's Encrypt state)
          timeout: 300s # Set timeout to 5 minutes
          command_timeout: 30m # Set command timeout to 30 minutes

      - name: Execute Full Deployment
        uses: appleboy/ssh-action@v1.0.3
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
          DB_USER: ${{ secrets.DB_USER }}
          DB_NAME: ${{ secrets.DB_NAME }}
          JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
          SSL_EMAIL: ${{ secrets.SSL_EMAIL }}
          DOMAIN: ${{ secrets.DOMAIN }}
          ALLOWED_ORIGINS: ${{ secrets.ALLOWED_ORIGINS }}
          EXTENSION_ORIGIN: ${{ secrets.EXTENSION_ORIGIN }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          debug: true
          timeout: 300s
          command_timeout: 30m
          envs: DB_PASSWORD,DB_USER,DB_NAME,JWT_SECRET_KEY,SSL_EMAIL,DOMAIN,ALLOWED_ORIGINS,EXTENSION_ORIGIN,DEPLOY_PATH
          script: |
            set -e
            cd ${DEPLOY_PATH}
            
            # Enable Docker Content Trust for image verification
            export DOCKER_CONTENT_TRUST=1
            
            # ===========================================
            # BACKUP SSL CERTS BEFORE EXTRACTION
            # Prevents rate limit issues by preserving existing certificates
            # ===========================================
            SSL_BACKUP_DIR="/tmp/ssl_backup_$$"
            if [ -d "nginx/ssl/live" ] || [ -d "nginx/ssl/archive" ]; then
              echo "=== Backing up SSL certificates ==="
              mkdir -p "$SSL_BACKUP_DIR"
              cp -a nginx/ssl/. "$SSL_BACKUP_DIR/" 2>/dev/null || true
              echo "SSL certs backed up to $SSL_BACKUP_DIR"
            fi
            
            # Unpack the deployment package
            tar xzf deploy_package.tar.gz
            rm deploy_package.tar.gz
            
            # ===========================================
            # RESTORE SSL CERTS AFTER EXTRACTION
            # ===========================================
            if [ -d "$SSL_BACKUP_DIR/live" ]; then
              echo "=== Restoring SSL certificates ==="
              rm -rf nginx/ssl/live nginx/ssl/archive nginx/ssl/renewal nginx/ssl/accounts 2>/dev/null || true
              cp -a "$SSL_BACKUP_DIR/." nginx/ssl/
              rm -rf "$SSL_BACKUP_DIR"
              echo "SSL certs restored successfully"
            fi

            # Replace placeholders in nginx configs with actual values from secrets
            echo "=== Substituting config placeholders with secrets ==="
            sed -i "s/__HOST_IP__/${{ secrets.HOST }}/g" nginx/nginx.http.conf
            sed -i "s/__HOST_IP__/${{ secrets.HOST }}/g" nginx/nginx.ssl.conf
            sed -i "s/__DOMAIN__/${DOMAIN}/g" nginx/nginx.http.conf
            sed -i "s/__DOMAIN__/${DOMAIN}/g" nginx/nginx.ssl.conf

            # Create .env file from environment variables
            echo "DB_PASSWORD=${DB_PASSWORD}" > .env
            echo "DB_USER=${DB_USER}" >> .env
            echo "DB_NAME=${DB_NAME}" >> .env
            echo "JWT_SECRET_KEY=${JWT_SECRET_KEY}" >> .env
            echo "SSL_EMAIL=${SSL_EMAIL}" >> .env
            echo "DOMAIN=${DOMAIN}" >> .env
            
            # Auto-detect SSL: Use HTTPS domain if cert exists, IP address otherwise
            SSL_CERT_PATH="./nginx/ssl/live/${DOMAIN}/fullchain.pem"
            if [ -f "$SSL_CERT_PATH" ]; then
              echo "API_URL=https://${DOMAIN}" >> .env
              echo "=== SSL certificate found, using HTTPS ==="
            else
              # Use IP address when SSL not available to avoid cross-origin issues
              echo "API_URL=http://${{ secrets.HOST }}" >> .env
              echo "=== No SSL certificate, using HTTP with IP ==="
            fi
            
            echo "ALLOWED_ORIGINS=${ALLOWED_ORIGINS}" >> .env
            # Used by docker-compose.prod.yml for env substitution into API container's ExtensionOrigins
            echo "EXTENSION_ORIGIN=${EXTENSION_ORIGIN}" >> .env
            
            echo "=== Checking existing containers ==="
            docker ps -a || true
            
            # Remove any manually created containers that might conflict
            echo "=== Cleaning up conflicting containers ==="
            docker rm -f clinics-nginx 2>/dev/null || true
            docker rm -f clinics-api 2>/dev/null || true
            docker rm -f clinics-web 2>/dev/null || true
            docker rm -f clinics-db 2>/dev/null || true
            
            # ===========================================
            # DATABASE PASSWORD SYNC (Single Source of Truth)
            # ===========================================
            # Ensure PostgreSQL user password matches GitHub Secrets
            if docker ps -q -f name=clinics-db-prod | grep -q .; then
              echo "=== Syncing DB password from GitHub Secrets ==="
              docker exec clinics-db-prod psql -U postgres -c "ALTER USER ${DB_USER} WITH PASSWORD '${DB_PASSWORD}';" 2>/dev/null || echo "DB password sync skipped (fresh install)"
            fi
            
            # ===========================================
            # SSL CERTIFICATE MANAGEMENT (Rate Limit Safe)
            # ===========================================
            SSL_CERT_PATH="./nginx/ssl/live/${DOMAIN}/fullchain.pem"
            CERTBOT_LOCK_FILE="/tmp/certbot_last_run"
            FORCE_SSL_RENEW="${{ inputs.force_ssl_renew }}"
            NEED_CERTBOT=false
            
            # Check if certificate exists
            if [ ! -f "$SSL_CERT_PATH" ]; then
              echo "=== No SSL certificate found ==="
              NEED_CERTBOT=true
            else
              # Check if certificate expires within 30 days
              EXPIRY_DATE=$(openssl x509 -enddate -noout -in "$SSL_CERT_PATH" 2>/dev/null | cut -d= -f2)
              if [ -n "$EXPIRY_DATE" ]; then
                EXPIRY_EPOCH=$(date -d "$EXPIRY_DATE" +%s 2>/dev/null || echo 0)
                NOW_EPOCH=$(date +%s)
                DAYS_LEFT=$(( (EXPIRY_EPOCH - NOW_EPOCH) / 86400 ))
                echo "=== SSL certificate expires in $DAYS_LEFT days ==="
                if [ "$DAYS_LEFT" -lt 30 ]; then
                  echo "=== Certificate expiring soon, renewal needed ==="
                  NEED_CERTBOT=true
                fi
              fi
            fi
            
            # Force renewal if manually triggered
            if [ "$FORCE_SSL_RENEW" = "true" ]; then
              echo "=== Force SSL renewal requested ==="
              NEED_CERTBOT=true
            fi
            
            # Rate limit protection: Check if certbot ran recently (within 6 hours)
            if [ "$NEED_CERTBOT" = "true" ] && [ -f "$CERTBOT_LOCK_FILE" ]; then
              LAST_RUN=$(cat "$CERTBOT_LOCK_FILE" 2>/dev/null || echo 0)
              NOW=$(date +%s)
              HOURS_SINCE=$(( (NOW - LAST_RUN) / 3600 ))
              if [ "$HOURS_SINCE" -lt 6 ] && [ "$FORCE_SSL_RENEW" != "true" ]; then
                echo "=== Certbot ran $HOURS_SINCE hours ago, skipping to avoid rate limit ==="
                NEED_CERTBOT=false
              fi
            fi
            
            # Run certbot if needed
            if [ "$NEED_CERTBOT" = "true" ]; then
              echo "=== Attempting to obtain SSL certificate ==="
              
              # Use HTTP-only nginx config first for ACME challenge
              if [ -f "nginx/nginx.http.conf" ]; then
                cp nginx/nginx.http.conf nginx/nginx.conf
              fi
              
              # Start/restart services with HTTP config
              docker compose -f docker-compose.prod.yml up -d --build --remove-orphans
              
              # Wait for services to be ready
              echo "Waiting for services to start..."
              sleep 15
              
              # Record attempt time (before running, to prevent rapid retries on failure)
              date +%s > "$CERTBOT_LOCK_FILE"
              
              # Obtain SSL certificate
              docker compose -f docker-compose.prod.yml --profile ssl run --rm certbot && {
                echo "=== SSL certificate obtained successfully ==="
                
                # Verify cert actually exists before switching to SSL
                if [ -f "$SSL_CERT_PATH" ] || [ -L "$SSL_CERT_PATH" ]; then
                  cp nginx/nginx.ssl.conf nginx/nginx.conf
                  docker compose -f docker-compose.prod.yml restart nginx
                  echo "=== Switched to HTTPS configuration ==="
                else
                  echo "=== WARNING: Certbot succeeded but cert not found, staying on HTTP ==="
                fi
              } || {
                echo "=== Certbot failed (possibly rate limited), continuing with HTTP ==="
                echo "=== Next retry allowed in 6 hours or with force_ssl_renew ==="
              }
            else
              # No certbot needed - decide between HTTP and HTTPS based on cert existence
              # Check for cert file OR symlink (Let's Encrypt uses symlinks)
              if [ -f "$SSL_CERT_PATH" ] || [ -L "$SSL_CERT_PATH" ]; then
                # Verify symlink target exists (cert not corrupted)
                if [ -e "$SSL_CERT_PATH" ]; then
                  echo "=== SSL certificate valid, using HTTPS config ==="
                  cp nginx/nginx.ssl.conf nginx/nginx.conf
                else
                  echo "=== SSL cert symlink broken, using HTTP config ==="
                  cp nginx/nginx.http.conf nginx/nginx.conf
                fi
              else
                echo "=== No SSL certificate, starting with HTTP config ==="
                cp nginx/nginx.http.conf nginx/nginx.conf
              fi
              
              # Build and start all services
              docker compose -f docker-compose.prod.yml up -d --build --remove-orphans
            fi
            
            # Wait for health checks
            echo "=== Waiting for services to be healthy ==="
            sleep 10
            
            # Verify deployment
            echo "=== Container Status ==="
            docker compose -f docker-compose.prod.yml ps
            
            # Reload nginx to ensure all config changes are applied
            echo "=== Reloading Nginx ==="
            docker exec clinics-nginx nginx -t && docker exec clinics-nginx nginx -s reload || echo "Nginx reload skipped"
            
            # Test health endpoint
            echo "=== Health Check ==="
            curl -sf http://127.0.0.1/health 2>/dev/null || curl -sf https://127.0.0.1/health --insecure 2>/dev/null || echo "Health check pending..."
            
            # Show container health status
            echo "=== Container Health ==="
            docker inspect --format='{{.Name}}: {{.State.Status}} {{if .State.Health}}({{.State.Health.Status}}){{end}}' $(docker ps -q) 2>/dev/null || true
            
            # Prune unused images
            docker image prune -f
            
            # ===========================================
            # SOURCE CODE CLEANUP
            # ===========================================
            # After images are built and containers are running,
            # source code is no longer needed on the server.
            # Keep only the files required to manage the deployment.
            echo "=== Cleaning up source code ==="
            
            # List of files/dirs to KEEP (needed for runtime management)
            # - docker-compose.prod.yml  (manage containers)
            # - .env                     (environment config)
            # - nginx/                   (reverse proxy config + SSL certs)
            # - DEPLOY.md               (reference docs)
            
            # Move keepers to a temp location
            CLEANUP_TMP="/tmp/deploy_keep_$$"
            mkdir -p "$CLEANUP_TMP/nginx"
            
            cp docker-compose.prod.yml "$CLEANUP_TMP/" 2>/dev/null || true
            cp .env "$CLEANUP_TMP/" 2>/dev/null || true
            cp -a nginx/. "$CLEANUP_TMP/nginx/" 2>/dev/null || true
            cp DEPLOY.md "$CLEANUP_TMP/" 2>/dev/null || true
            
            # Remove everything in deploy path
            find "${DEPLOY_PATH}" -mindepth 1 -maxdepth 1 ! -name '.' -exec rm -rf {} +
            
            # Restore keepers
            cp -a "$CLEANUP_TMP/." "${DEPLOY_PATH}/"
            rm -rf "$CLEANUP_TMP"
            
            echo "=== Source code removed. Only runtime files remain ==="
            ls -la "${DEPLOY_PATH}"
            
            # ===========================================
            # SECURITY HARDENING (runs on each deploy)
            # ===========================================
            echo "=== Applying Security Hardening ==="
            
            # 1. Secure file permissions for sensitive files
            chmod 600 .env 2>/dev/null || true
            chmod 600 nginx/ssl/live/${DOMAIN}/privkey.pem 2>/dev/null || true
            
            # 2. Remove unnecessary packages and clear temp files
            rm -rf /tmp/* 2>/dev/null || true
            
            # 3. Verify UFW is active
            if command -v ufw &> /dev/null; then
              echo "UFW Status:"
              sudo ufw status | head -5
            fi
            
            # 4. Verify Fail2Ban is active
            if command -v fail2ban-client &> /dev/null; then
              echo "Fail2Ban Status:"
              sudo fail2ban-client status | head -3
            fi
            
            # 5. Show security summary
            echo "=== Security Summary ==="
            echo "- .env file permissions: $(stat -c '%a' .env 2>/dev/null || echo 'N/A')"
            echo "- SSL cert expires: $(openssl x509 -enddate -noout -in nginx/ssl/live/${DOMAIN}/fullchain.pem 2>/dev/null | cut -d= -f2 || echo 'N/A')"
            echo "- Docker containers running: $(docker ps -q | wc -l)"
            
            echo "=== Deployment complete ==="
